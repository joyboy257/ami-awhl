{
    "name": "W-3: Site Discovery (Hardened)",
    "nodes": [
        {
            "parameters": {},
            "id": "w3-trigger",
            "name": "Manual Trigger",
            "type": "n8n-nodes-base.manualTrigger",
            "typeVersion": 1,
            "position": [
                100,
                300
            ]
        },
        {
            "parameters": {
                "operation": "executeQuery",
                "query": "-- W-3 responsibility: Discovery quality (real URL yield), NOT body classification\n-- Select domains with pending discovery or zero pages\nSELECT d.id as domain_id, d.domain\nFROM wellness.domains d\nWHERE (d.discovery_state = 'pending' \n       OR (d.discovery_state = 'complete' AND NOT EXISTS (SELECT 1 FROM wellness.pages p WHERE p.domain_id = d.id)))\n  AND d.domain IS NOT NULL AND d.domain != '' AND length(d.domain) >= 4\nLIMIT 20;"
            },
            "id": "w3-get-domains",
            "name": "Get Domains",
            "type": "n8n-nodes-base.postgres",
            "typeVersion": 2.6,
            "position": [
                300,
                300
            ],
            "credentials": {
                "postgres": {
                    "id": "postgres-creds-id",
                    "name": "Postgres account"
                }
            }
        },
        {
            "parameters": {
                "batchSize": 1,
                "options": {}
            },
            "id": "w3-split",
            "name": "Split Domains",
            "type": "n8n-nodes-base.splitInBatches",
            "typeVersion": 3,
            "position": [
                500,
                300
            ]
        },
        {
            "parameters": {
                "jsCode": "// W-3 Hardened: Discovery with sitemap index recursion, gzip, namespace tolerance\n// Responsibility: real URL yield, NOT body classification\n\nconst d = $input.item.json;\nconst domain = d.domain;\nconst domain_id = d.domain_id;\n\n// Build list of sitemap URLs to try\nconst sitemapUrls = [\n  `https://${domain}/sitemap.xml`,\n  `https://${domain}/sitemap_index.xml`,\n  `https://www.${domain}/sitemap.xml`,\n  `https://${domain}/sitemap.xml.gz`\n];\n\nreturn [{ json: { \n  domain_id, \n  domain, \n  sitemap_urls: sitemapUrls,\n  current_index: 0,\n  discovered_urls: [],\n  child_sitemaps: [],\n  recursion_depth: 0,\n  max_depth: 3\n}}];"
            },
            "id": "w3-prep",
            "name": "Prep Domain",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                700,
                300
            ]
        },
        {
            "parameters": {
                "operation": "executeQuery",
                "query": "UPDATE wellness.domains SET discovery_state = 'in_progress' WHERE id = $1::uuid;",
                "options": {
                    "queryReplacement": "={{ [$json.domain_id] }}"
                }
            },
            "id": "w3-lock",
            "name": "Lock Domain",
            "type": "n8n-nodes-base.postgres",
            "typeVersion": 2.6,
            "position": [
                900,
                300
            ],
            "credentials": {
                "postgres": {
                    "id": "postgres-creds-id",
                    "name": "Postgres account"
                }
            }
        },
        {
            "parameters": {
                "jsCode": "// Restore context after Lock and begin sitemap fetching\nconst prev = $('Prep Domain').item.json;\nreturn [{ json: prev }];"
            },
            "id": "w3-restore",
            "name": "Restore Context",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                1100,
                300
            ]
        },
        {
            "parameters": {
                "jsCode": "// Fetch and parse all sitemaps with recursion support\nconst data = $input.item.json;\nconst domain = data.domain;\nconst domain_id = data.domain_id;\nlet discovered_urls = data.discovered_urls || [];\nlet child_sitemaps = data.child_sitemaps || [];\nconst recursion_depth = data.recursion_depth || 0;\nconst max_depth = data.max_depth || 3;\n\n// Helper: Parse sitemap XML with namespace tolerance\nfunction parseSitemap(xml) {\n  const result = { urls: [], sitemaps: [] };\n  if (!xml || typeof xml !== 'string' || xml.length < 50) return result;\n  \n  // Remove CDATA and clean\n  let clean = xml.replace(/<!\\[CDATA\\[/g, '').replace(/\\]\\]>/g, '');\n  \n  // Check if this is a sitemap index (contains <sitemap><loc>)\n  const isSitemapIndex = clean.includes('<sitemapindex') || clean.includes('<sitemap>');\n  \n  // Extract <loc> URLs - handle namespaced and non-namespaced\n  // Patterns: <loc>, <ns:loc>, <sitemap:loc>\n  const locPattern = /<(?:[a-z0-9]+:)?loc>\\s*([^<]+)\\s*<\\/(?:[a-z0-9]+:)?loc>/gi;\n  let match;\n  while ((match = locPattern.exec(clean)) !== null) {\n    const url = match[1].trim();\n    if (url && url.startsWith('http')) {\n      // Determine if this is a child sitemap or a content URL\n      if (isSitemapIndex && (url.endsWith('.xml') || url.endsWith('.xml.gz') || url.includes('sitemap'))) {\n        result.sitemaps.push(url);\n      } else {\n        result.urls.push(url);\n      }\n    }\n  }\n  \n  return result;\n}\n\n// Fetch helper with gzip support\nasync function fetchSitemap(url) {\n  try {\n    const resp = await this.helpers.request({\n      method: 'GET',\n      url: url,\n      timeout: 15000,\n      encoding: url.endsWith('.gz') ? null : 'utf8',\n      headers: {\n        'User-Agent': 'Mozilla/5.0 (compatible; AMI-Bot/1.0)',\n        'Accept': 'application/xml, text/xml, */*',\n        'Accept-Encoding': 'gzip, deflate'\n      },\n      resolveWithFullResponse: false,\n      simple: false\n    });\n    \n    // Handle gzip - n8n should auto-decompress, but verify\n    if (typeof resp === 'string') return resp;\n    if (resp && resp.body) return resp.body;\n    return '';\n  } catch (e) {\n    return '';\n  }\n}\n\n// Process sitemap URLs to try\nconst sitemapUrls = data.sitemap_urls || [];\n\nfor (const sitemapUrl of sitemapUrls) {\n  // Skip if we've already discovered enough\n  if (discovered_urls.length >= 500) break;\n  \n  const xml = await fetchSitemap.call(this, sitemapUrl);\n  if (!xml) continue;\n  \n  const parsed = parseSitemap(xml);\n  \n  // Add discovered URLs\n  discovered_urls = discovered_urls.concat(parsed.urls);\n  \n  // Add child sitemaps for recursion\n  if (recursion_depth < max_depth) {\n    child_sitemaps = child_sitemaps.concat(parsed.sitemaps);\n  }\n}\n\n// Process child sitemaps (recursion)\nif (child_sitemaps.length > 0 && recursion_depth < max_depth) {\n  for (const childUrl of child_sitemaps.slice(0, 20)) {\n    if (discovered_urls.length >= 500) break;\n    \n    const xml = await fetchSitemap.call(this, childUrl);\n    if (!xml) continue;\n    \n    const parsed = parseSitemap(xml);\n    discovered_urls = discovered_urls.concat(parsed.urls);\n  }\n}\n\n// Dedupe and filter\nconst uniqueUrls = [...new Set(discovered_urls)];\n\n// Filter out obvious non-content URLs\nconst contentUrls = uniqueUrls.filter(url => {\n  // Keep all URLs - Layer-1 prefilter is in W-4, not here\n  // W-3 responsibility is discovery yield, not classification\n  return url.startsWith('http');\n}).slice(0, 200);\n\nif (contentUrls.length === 0) {\n  return [{ json: { domain_id, domain, _skip: true, urls_found: 0 }}];\n}\n\n// Return URLs for insertion\nreturn contentUrls.map(url => ({ json: { domain_id, domain, url }}));"
            },
            "id": "w3-fetch-parse",
            "name": "Fetch and Parse Sitemaps",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                1300,
                300
            ]
        },
        {
            "parameters": {
                "conditions": {
                    "options": {
                        "caseSensitive": true,
                        "leftValue": "",
                        "typeValidation": "strict"
                    },
                    "conditions": [
                        {
                            "id": "has-url",
                            "leftValue": "={{ $json.url }}",
                            "rightValue": "",
                            "operator": {
                                "type": "string",
                                "operation": "notEmpty"
                            }
                        }
                    ],
                    "combinator": "and"
                },
                "options": {}
            },
            "id": "w3-filter",
            "name": "Filter Valid URLs",
            "type": "n8n-nodes-base.if",
            "typeVersion": 2,
            "position": [
                1500,
                300
            ]
        },
        {
            "parameters": {
                "operation": "executeQuery",
                "query": "INSERT INTO wellness.pages (domain_id, url)\nVALUES ($1::uuid, $2)\nON CONFLICT (domain_id, url) DO UPDATE SET last_seen_at = NOW();",
                "options": {
                    "queryReplacement": "={{ [$json.domain_id, $json.url] }}"
                }
            },
            "id": "w3-upsert",
            "name": "Upsert Pages",
            "type": "n8n-nodes-base.postgres",
            "typeVersion": 2.6,
            "position": [
                1700,
                250
            ],
            "credentials": {
                "postgres": {
                    "id": "postgres-creds-id",
                    "name": "Postgres account"
                }
            },
            "continueOnFail": true
        },
        {
            "parameters": {
                "jsCode": "// Aggregate after inserts and prep for completion\n// CRITICAL: Get domain context from Prep Domain to avoid empty uuid\nconst prepData = $('Prep Domain').item.json;\nconst items = $input.all();\nconst urlsInserted = items.filter(i => i.json.url).length;\n\nreturn [{ json: { \n  domain_id: prepData.domain_id, \n  domain: prepData.domain, \n  urls_inserted: urlsInserted \n}}];"
            },
            "id": "w3-aggregate",
            "name": "Aggregate Results",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                1900,
                300
            ]
        },
        {
            "parameters": {
                "operation": "executeQuery",
                "query": "UPDATE wellness.domains SET discovery_state = 'complete' WHERE id = $1::uuid;",
                "options": {
                    "queryReplacement": "={{ [$json.domain_id] }}"
                }
            },
            "id": "w3-complete",
            "name": "Complete Domain",
            "type": "n8n-nodes-base.postgres",
            "typeVersion": 2.6,
            "position": [
                2100,
                300
            ],
            "credentials": {
                "postgres": {
                    "id": "postgres-creds-id",
                    "name": "Postgres account"
                }
            }
        },
        {
            "parameters": {
                "jsCode": "return [{ json: { done: true }}];"
            },
            "id": "w3-continue",
            "name": "Continue",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                2300,
                300
            ]
        },
        {
            "parameters": {
                "jsCode": "// Handle skip case (no URLs found)\n// CRITICAL: Get domain context from Prep Domain to avoid empty uuid\nconst prepData = $('Prep Domain').item.json;\nreturn [{ json: { domain_id: prepData.domain_id, domain: prepData.domain, urls_inserted: 0 }}];"
            },
            "id": "w3-skip-handler",
            "name": "Handle Skip",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                1700,
                400
            ]
        },
        {
            "parameters": {},
            "id": "w3-done",
            "name": "Done",
            "type": "n8n-nodes-base.noOp",
            "typeVersion": 1,
            "position": [
                700,
                500
            ]
        }
    ],
    "connections": {
        "Manual Trigger": {
            "main": [
                [
                    {
                        "node": "Get Domains",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Get Domains": {
            "main": [
                [
                    {
                        "node": "Split Domains",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Split Domains": {
            "main": [
                [
                    {
                        "node": "Prep Domain",
                        "type": "main",
                        "index": 0
                    }
                ],
                [
                    {
                        "node": "Done",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Prep Domain": {
            "main": [
                [
                    {
                        "node": "Lock Domain",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Lock Domain": {
            "main": [
                [
                    {
                        "node": "Restore Context",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Restore Context": {
            "main": [
                [
                    {
                        "node": "Fetch and Parse Sitemaps",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Fetch and Parse Sitemaps": {
            "main": [
                [
                    {
                        "node": "Filter Valid URLs",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Filter Valid URLs": {
            "main": [
                [
                    {
                        "node": "Upsert Pages",
                        "type": "main",
                        "index": 0
                    }
                ],
                [
                    {
                        "node": "Handle Skip",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Upsert Pages": {
            "main": [
                [
                    {
                        "node": "Aggregate Results",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Handle Skip": {
            "main": [
                [
                    {
                        "node": "Aggregate Results",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Aggregate Results": {
            "main": [
                [
                    {
                        "node": "Complete Domain",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Complete Domain": {
            "main": [
                [
                    {
                        "node": "Continue",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Continue": {
            "main": [
                [
                    {
                        "node": "Split Domains",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        }
    },
    "settings": {
        "executionOrder": "v1"
    },
    "active": false
}