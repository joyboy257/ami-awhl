{
    "name": "W-3: Site Discovery",
    "nodes": [
        {
            "parameters": {},
            "id": "w3-trigger",
            "name": "Manual Trigger",
            "type": "n8n-nodes-base.manualTrigger",
            "typeVersion": 1,
            "position": [
                100,
                300
            ]
        },
        {
            "parameters": {
                "operation": "executeQuery",
                "query": "SELECT d.id as domain_id, d.domain\nFROM wellness.domains d\nWHERE d.discovery_state = 'pending'\n  AND d.domain IS NOT NULL AND d.domain != '' AND length(d.domain) >= 4\nLIMIT 20;"
            },
            "id": "w3-get-domains",
            "name": "Get Domains",
            "type": "n8n-nodes-base.postgres",
            "typeVersion": 2.6,
            "position": [
                300,
                300
            ],
            "credentials": {
                "postgres": {
                    "id": "postgres-creds-id",
                    "name": "Postgres account"
                }
            }
        },
        {
            "parameters": {
                "batchSize": 1,
                "options": {}
            },
            "id": "w3-split",
            "name": "Split Domains",
            "type": "n8n-nodes-base.splitInBatches",
            "typeVersion": 3,
            "position": [
                500,
                300
            ]
        },
        {
            "parameters": {
                "jsCode": "// Prepare domain context - keep domain_id and domain for later\nconst d = $input.item.json;\nreturn [{ json: { \n  domain_id: d.domain_id, \n  domain: d.domain, \n  sitemap_url: 'https://' + d.domain + '/sitemap.xml' \n}}];"
            },
            "id": "w3-prep",
            "name": "Prep Domain",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                650,
                300
            ]
        },
        {
            "parameters": {
                "operation": "executeQuery",
                "query": "UPDATE wellness.domains d SET discovery_state = 'in_progress' WHERE d.id = '{{ $json.domain_id }}'::uuid RETURNING d.id as domain_id, d.domain, 'https://' || d.domain || '/sitemap.xml' as sitemap_url;"
            },
            "id": "w3-lock",
            "name": "Lock Domain",
            "type": "n8n-nodes-base.postgres",
            "typeVersion": 2.6,
            "position": [
                850,
                300
            ],
            "credentials": {
                "postgres": {
                    "id": "postgres-creds-id",
                    "name": "Postgres account"
                }
            }
        },
        {
            "parameters": {
                "jsCode": "// Restore domain context after Lock (which returns nothing useful)\n// We need to get back our domain_id, domain, sitemap_url from Prep Domain\n// Since we can't use $node refs, we'll get it from the execution context\n// Workaround: Pass through from input - Lock Domain receives data from Prep Domain\nconst prev = $input.item.json;\n// After DB update, $input.item.json has the Lock result (empty or just confirmation)\n// We need to reconstruct - get from Prep Domain output which was passed to Lock\n// Since we're in a chain: Prep -> Lock -> this node, prev has Lock output\n// Solution: Store in a way that survives the DB node\n// Actually Lock receives {domain_id, domain, sitemap_url} and passes it through\nreturn [{ json: prev }];"
            },
            "id": "w3-restore",
            "name": "Restore Context",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                1000,
                300
            ]
        },
        {
            "parameters": {
                "url": "={{ $json.sitemap_url }}",
                "options": {
                    "timeout": 20000
                }
            },
            "id": "w3-fetch",
            "name": "Fetch Sitemap",
            "type": "n8n-nodes-base.httpRequest",
            "typeVersion": 4.2,
            "position": [
                1200,
                300
            ],
            "continueOnFail": true
        },
        {
            "parameters": {
                "jsCode": "// After HTTP fetch, we lose domain context\n// We need to extract domain from sitemap URL in the response or use a workaround\n// The HTTP response replaces our data - we need to get domain from the URL itself\nconst resp = $input.item.json;\n\n// Try to get sitemap URL from response headers or reconstruct\nlet domain = '';\nlet domain_id = '';\n\n// The only way: extract from response URL if available\nif (resp.url) {\n  const match = resp.url.match(/^https?:\\/\\/(?:www\\.)?([^\\/:]+)/i);\n  if (match) domain = match[1].toLowerCase();\n}\n\n// Get XML content\nlet xml = '';\nif (typeof resp === 'string') xml = resp;\nelse if (resp.data) xml = resp.data;\nelse if (resp.body) xml = resp.body;\n\n// We need domain_id - lookup from DB would be needed\n// For now, we'll use domain to lookup later\nreturn [{ json: { domain, _xml: xml, _needsDomainId: true } }];"
            },
            "id": "w3-merge",
            "name": "Merge Fetch",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                1400,
                300
            ]
        },
        {
            "parameters": {
                "jsCode": "// Parse sitemap XML and extract URLs\n// Extract domain from the URLs found since context was lost\nconst data = $input.item.json;\nconst xml = data._xml || '';\nlet domain = data.domain || '';\n\nfunction extractDomain(urlStr) {\n  if (!urlStr) return null;\n  const match = urlStr.match(/^https?:\\/\\/(?:www\\.)?([^\\/:]+)/i);\n  return match ? match[1].toLowerCase() : null;\n}\n\nconst urls = [];\nif (xml && typeof xml === 'string' && xml.length > 50) {\n  const cleanXml = xml.replace(/<!\\[CDATA\\[/g, '').replace(/\\]\\]>/g, '');\n  const locMatches = cleanXml.match(/<loc>([^<]+)<\\/loc>/g) || [];\n  \n  for (const match of locMatches) {\n    const url = match.replace('<loc>', '').replace('</loc>', '').trim();\n    if (url && url.startsWith('http')) {\n      // Extract domain from the URL if we don't have it\n      if (!domain) {\n        domain = extractDomain(url) || '';\n      }\n      urls.push({ url, domain });\n    }\n  }\n}\n\nif (urls.length === 0) {\n  return [{ json: { _skip: true, domain } }];\n}\n\nreturn urls.slice(0, 100).map(u => ({ json: u }));"
            },
            "id": "w3-parse",
            "name": "Parse Sitemap",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                1600,
                300
            ]
        },
        {
            "parameters": {
                "conditions": {
                    "boolean": [
                        {
                            "value1": "={{ $json._skip !== true && $json.url }}",
                            "value2": true
                        }
                    ]
                }
            },
            "id": "w3-filter",
            "name": "Filter Valid",
            "type": "n8n-nodes-base.if",
            "typeVersion": 2,
            "position": [
                1800,
                300
            ]
        },
        {
            "parameters": {
                "operation": "executeQuery",
                "query": "WITH ins AS (\n  INSERT INTO wellness.pages (domain_id, url)\n  SELECT d.id, '{{ $json.url }}'\n  FROM wellness.domains d WHERE d.domain = '{{ $json.domain }}'\n  ON CONFLICT (domain_id, url) DO UPDATE SET last_seen_at = NOW()\n  RETURNING domain_id\n)\nSELECT d.domain FROM ins JOIN wellness.domains d ON d.id = ins.domain_id;"
            },
            "id": "w3-upsert",
            "name": "Upsert Pages",
            "type": "n8n-nodes-base.postgres",
            "typeVersion": 2.6,
            "position": [
                2000,
                250
            ],
            "credentials": {
                "postgres": {
                    "id": "postgres-creds-id",
                    "name": "Postgres account"
                }
            },
            "continueOnFail": true
        },
        {
            "parameters": {
                "jsCode": "// Get domain for completion - use first() for Run Once mode\nconst items = $input.all();\nif (items.length === 0) return [{ json: { domain: '' } }];\nconst item = items[0].json;\nreturn [{ json: { domain: item.domain || '' } }];"
            },
            "id": "w3-prep-complete",
            "name": "Prep Complete",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                2200,
                300
            ]
        },
        {
            "parameters": {
                "operation": "executeQuery",
                "query": "UPDATE wellness.domains SET discovery_state = 'complete' WHERE domain = '{{ $json.domain }}';"
            },
            "id": "w3-complete",
            "name": "Complete Domain",
            "type": "n8n-nodes-base.postgres",
            "typeVersion": 2.6,
            "position": [
                2400,
                300
            ],
            "credentials": {
                "postgres": {
                    "id": "postgres-creds-id",
                    "name": "Postgres account"
                }
            }
        }
    ],
    "connections": {
        "Manual Trigger": {
            "main": [
                [
                    {
                        "node": "Get Domains",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Get Domains": {
            "main": [
                [
                    {
                        "node": "Split Domains",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Split Domains": {
            "main": [
                [
                    {
                        "node": "Prep Domain",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Prep Domain": {
            "main": [
                [
                    {
                        "node": "Lock Domain",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Lock Domain": {
            "main": [
                [
                    {
                        "node": "Restore Context",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Restore Context": {
            "main": [
                [
                    {
                        "node": "Fetch Sitemap",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Fetch Sitemap": {
            "main": [
                [
                    {
                        "node": "Merge Fetch",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Merge Fetch": {
            "main": [
                [
                    {
                        "node": "Parse Sitemap",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Parse Sitemap": {
            "main": [
                [
                    {
                        "node": "Filter Valid",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Filter Valid": {
            "main": [
                [
                    {
                        "node": "Upsert Pages",
                        "type": "main",
                        "index": 0
                    }
                ],
                [
                    {
                        "node": "Prep Complete",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Upsert Pages": {
            "main": [
                [
                    {
                        "node": "Prep Complete",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Prep Complete": {
            "main": [
                [
                    {
                        "node": "Complete Domain",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Complete Domain": {
            "main": [
                [
                    {
                        "node": "Split Domains",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        }
    },
    "settings": {
        "executionOrder": "v1"
    },
    "active": false
}